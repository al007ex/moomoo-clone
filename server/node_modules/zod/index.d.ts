export class ZodError extends Error {
  constructor(message?: string, issues?: unknown[]);
  issues: unknown[];
}

export class ZodType<T = any> {
  parse(input: unknown): T;
  safeParse(input: unknown): { success: true; data: T } | { success: false; error: ZodError };
  optional(): ZodType<T | undefined>;
  default(value: T | (() => T)): ZodType<T>;
  transform<U>(fn: (value: T) => U): ZodType<U>;
  refine(check: (value: T) => boolean, message?: string): ZodType<T>;
}

export function literal<T>(value: T): ZodType<T>;
export function string(): ZodType<string>;
export function number(): ZodType<number>;
export function boolean(): ZodType<boolean>;
export function any(): ZodType<any>;
export function union<T extends ZodType<any>[]>(schemas: T): ZodType<any>;
export function array<T>(schema: ZodType<T>): ZodType<T[]>;
export function tuple<T extends ZodType<any>[]>(schemas: T): ZodType<any[]>;
export function object<T extends Record<string, ZodType<any>>>(shape: T): ZodType<{ [K in keyof T]?: ReturnType<T[K]["parse"]> } & Record<string, any>>;
export function nativeEnum<T extends Record<string, string | number>>(enumObj: T): ZodType<T[keyof T]>;

export const z: {
  ZodError: typeof ZodError;
  literal: typeof literal;
  string: typeof string;
  number: typeof number;
  boolean: typeof boolean;
  any: typeof any;
  union: typeof union;
  array: typeof array;
  tuple: typeof tuple;
  object: typeof object;
  nativeEnum: typeof nativeEnum;
};

const _default: {
  ZodError: typeof ZodError;
  z: typeof z;
  literal: typeof literal;
  string: typeof string;
  number: typeof number;
  boolean: typeof boolean;
  any: typeof any;
  union: typeof union;
  array: typeof array;
  tuple: typeof tuple;
  object: typeof object;
  nativeEnum: typeof nativeEnum;
};

export default _default;
