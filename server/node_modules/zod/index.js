class ZodError extends Error {
  constructor(message, issues = []) {
    super(message);
    this.name = "ZodError";
    this.issues = issues;
  }
}

class ZodType {
  parse(input) {
    return this._parse(input);
  }

  safeParse(input) {
    try {
      const data = this.parse(input);
      return { success: true, data };
    } catch (error) {
      const err = error instanceof ZodError ? error : new ZodError(String(error));
      return { success: false, error: err };
    }
  }

  optional() {
    return new ZodOptional(this);
  }

  default(value) {
    return new ZodDefault(this, value);
  }

  transform(transformer) {
    return new ZodTransform(this, transformer);
  }

  refine(check, message = "Refinement failed") {
    return new ZodRefinement(this, check, message);
  }
}

class ZodOptional extends ZodType {
  constructor(inner) {
    super();
    this.inner = inner;
  }

  _parse(input) {
    if (input === undefined) {
      return undefined;
    }
    return this.inner.parse(input);
  }
}

class ZodDefault extends ZodType {
  constructor(inner, defaultValue) {
    super();
    this.inner = inner;
    this.defaultValue = defaultValue;
  }

  _parse(input) {
    if (input === undefined) {
      return typeof this.defaultValue === "function"
        ? this.defaultValue()
        : this.defaultValue;
    }
    return this.inner.parse(input);
  }
}

class ZodTransform extends ZodType {
  constructor(inner, transformer) {
    super();
    this.inner = inner;
    this.transformer = transformer;
  }

  _parse(input) {
    const value = this.inner.parse(input);
    return this.transformer(value);
  }
}

class ZodRefinement extends ZodType {
  constructor(inner, check, message) {
    super();
    this.inner = inner;
    this.check = check;
    this.message = message;
  }

  _parse(input) {
    const value = this.inner.parse(input);
    if (!this.check(value)) {
      throw new ZodError(this.message, [{ message: this.message, path: [] }]);
    }
    return value;
  }
}

class ZodLiteral extends ZodType {
  constructor(value) {
    super();
    this.value = value;
  }

  _parse(input) {
    if (input !== this.value) {
      throw new ZodError(`Expected literal ${this.value}`);
    }
    return input;
  }
}

class ZodString extends ZodType {
  constructor() {
    super();
    this._min = null;
    this._max = null;
  }

  _parse(input) {
    if (typeof input !== "string") {
      throw new ZodError("Expected string");
    }
    if (this._min !== null && input.length < this._min) {
      throw new ZodError(`Expected string length >= ${this._min}`);
    }
    if (this._max !== null && input.length > this._max) {
      throw new ZodError(`Expected string length <= ${this._max}`);
    }
    return input;
  }

  min(len) {
    const clone = new ZodString();
    clone._min = len;
    clone._max = this._max;
    return clone;
  }

  max(len) {
    const clone = new ZodString();
    clone._min = this._min;
    clone._max = len;
    return clone;
  }
}

class ZodNumber extends ZodType {
  constructor() {
    super();
    this._min = null;
    this._max = null;
  }

  _parse(input) {
    if (typeof input !== "number" || Number.isNaN(input)) {
      throw new ZodError("Expected number");
    }
    if (this._min !== null && input < this._min) {
      throw new ZodError(`Expected number >= ${this._min}`);
    }
    if (this._max !== null && input > this._max) {
      throw new ZodError(`Expected number <= ${this._max}`);
    }
    return input;
  }

  min(value) {
    const clone = new ZodNumber();
    clone._min = value;
    clone._max = this._max;
    return clone;
  }

  max(value) {
    const clone = new ZodNumber();
    clone._min = this._min;
    clone._max = value;
    return clone;
  }
}

class ZodBoolean extends ZodType {
  _parse(input) {
    if (typeof input !== "boolean") {
      throw new ZodError("Expected boolean");
    }
    return input;
  }
}

class ZodAny extends ZodType {
  _parse(input) {
    return input;
  }
}

class ZodNativeEnum extends ZodType {
  constructor(enumObj) {
    super();
    this.values = new Set(Object.values(enumObj));
  }

  _parse(input) {
    if (!this.values.has(input)) {
      throw new ZodError("Expected enum value");
    }
    return input;
  }
}

class ZodUnion extends ZodType {
  constructor(options) {
    super();
    this.options = options;
  }

  _parse(input) {
    const issues = [];
    for (const option of this.options) {
      try {
        return option.parse(input);
      } catch (error) {
        issues.push(error);
      }
    }
    throw new ZodError("No union variant matched", issues);
  }
}

class ZodArray extends ZodType {
  constructor(schema) {
    super();
    this.schema = schema;
    this._min = null;
    this._max = null;
  }

  _parse(input) {
    if (!Array.isArray(input)) {
      throw new ZodError("Expected array");
    }
    if (this._min !== null && input.length < this._min) {
      throw new ZodError(`Expected array length >= ${this._min}`);
    }
    if (this._max !== null && input.length > this._max) {
      throw new ZodError(`Expected array length <= ${this._max}`);
    }
    return input.map(item => this.schema.parse(item));
  }

  min(len) {
    const clone = new ZodArray(this.schema);
    clone._min = len;
    clone._max = this._max;
    return clone;
  }

  max(len) {
    const clone = new ZodArray(this.schema);
    clone._min = this._min;
    clone._max = len;
    return clone;
  }
}

class ZodTuple extends ZodType {
  constructor(items) {
    super();
    this.items = items;
  }

  _parse(input) {
    if (!Array.isArray(input)) {
      throw new ZodError("Expected tuple (array)");
    }
    const result = [];
    for (let i = 0; i < this.items.length; i++) {
      const schema = this.items[i];
      const value = input[i];
      try {
        result[i] = schema.parse(value);
      } catch (error) {
        if (value === undefined && schema instanceof ZodOptional) {
          result[i] = undefined;
          continue;
        }
        throw error instanceof ZodError ? error : new ZodError(String(error));
      }
    }
    return result;
  }
}

class ZodObject extends ZodType {
  constructor(shape) {
    super();
    this.shape = shape;
  }

  _parse(input) {
    if (typeof input !== "object" || input === null || Array.isArray(input)) {
      throw new ZodError("Expected object");
    }
    const result = { ...input };
    for (const key of Object.keys(this.shape)) {
      const schema = this.shape[key];
      const value = input[key];
      if (value === undefined) {
        const parsed = schema.parse(undefined);
        if (parsed !== undefined) {
          result[key] = parsed;
        }
        continue;
      }
      result[key] = schema.parse(value);
    }
    return result;
  }
}

function literal(value) {
  return new ZodLiteral(value);
}

function string() {
  return new ZodString();
}

function number() {
  return new ZodNumber();
}

function boolean() {
  return new ZodBoolean();
}

function any() {
  return new ZodAny();
}

function union(options) {
  return new ZodUnion(options);
}

function array(schema) {
  return new ZodArray(schema);
}

function tuple(items) {
  return new ZodTuple(items);
}

function object(shape) {
  return new ZodObject(shape);
}

function nativeEnum(enumObj) {
  return new ZodNativeEnum(enumObj);
}

export {
  ZodError,
  ZodType,
  literal,
  string,
  number,
  boolean,
  any,
  union,
  array,
  tuple,
  object,
  nativeEnum
};

export const z = {
  ZodError,
  literal,
  string,
  number,
  boolean,
  any,
  union,
  array,
  tuple,
  object,
  nativeEnum
};

export default {
  ZodError,
  z,
  literal,
  string,
  number,
  boolean,
  any,
  union,
  array,
  tuple,
  object,
  nativeEnum
};
